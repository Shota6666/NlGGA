<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>In-Game Screen</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&amp;display=swap"
    rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: "#FFCC00",
            secondary: "#FF9900",
            "background-light": "#FFFBEB",
            "background-dark": "#1F1F1F",
            "surface-light": "rgba(255, 255, 255, 0.6)",
            "surface-dark": "rgba(0, 0, 0, 0.4)",
          },
          fontFamily: {
            display: ["'Noto Sans TC'", "sans-serif"],
          },
          borderRadius: {
            DEFAULT: "1rem",
            'xl': "1.5rem",
            '2xl': "2rem",
          },
          boxShadow: {
            'soft': '0 4px 20px -2px rgba(0, 0, 0, 0.1)',
            'glow': '0 0 15px rgba(255, 204, 0, 0.5)',
          }
        },
      },
    };
  </script>
  <style>
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }

    .ar-duck {
      animation: float 3s ease-in-out infinite;
    }

    body::-webkit-scrollbar {
      display: none;
    }

    .scan-line {
      width: 100%;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      animation: scan 3s linear infinite;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
    }

    @keyframes scan {
      0% { transform: translateY(-200px); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(200px); opacity: 0; }
    }

    body {
      min-height: 100dvh;
      height: 100dvh;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "cannon-es": "https://esm.sh/cannon-es@0.20.0"
      }
    }
  </script>

  <script src="js/global_audio.js"></script>
  <script type="module">

    import * as THREE from 'three';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import * as CANNON from 'cannon-es';

    document.addEventListener('DOMContentLoaded', () => {
      initGame();
    });

    function initGame() {
      const container = document.getElementById('canvas-container');
      if (!container) return;

      // --- 1. Three.js Setup ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
      const initialCameraPos = new THREE.Vector3(0, 100, 400);
      const targetCameraPos = initialCameraPos.clone();
      camera.position.copy(initialCameraPos);
      camera.lookAt(0, 30, 0);

      // AR Background Setup
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const video = document.createElement('video');
        video.playsInline = true;
        video.autoplay = true;
        video.muted = true;
        video.style.display = 'none';

        const constraints = {
          video: { facingMode: 'environment' },
          audio: false
        };

        navigator.mediaDevices.getUserMedia(constraints)
          .then(function (stream) {
            video.srcObject = stream;
            video.play();
            const texture = new THREE.VideoTexture(video);
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.background = texture;
          })
          .catch(function (err) {
            console.error('AR Error:', err);
            scene.background = new THREE.Color(0xf0f0f0);
          });
      } else {
        scene.background = new THREE.Color(0xf0f0f0);
      }

      // --- 修改：增強燈光 (Brighten Models) ---
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5); // 強度提升到 2.5
      hemiLight.position.set(0, 1000, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 2.0); // 強度提升到 2.0
      dirLight.position.set(100, 1000, 100);
      dirLight.castShadow = true;
      scene.add(dirLight);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.outputColorSpace = THREE.SRGBColorSpace; // 確保色彩鮮豔
      container.appendChild(renderer.domElement);

      // --- Cannon.js Physics Setup ---
      const world = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82 * 20, 0),
      });

      const defaultMaterial = new CANNON.Material('default');
      const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
        friction: 1000.0,
        restitution: 0.0,
        contactEquationStiffness: 1e8,
        contactEquationRelaxation: 3,
      });
      world.addContactMaterial(defaultContactMaterial);

      const groundShape = new CANNON.Box(new CANNON.Vec3(50, 5, 50));
      const groundBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: groundShape,
        material: defaultMaterial
      });
      groundBody.position.set(0, -35, 0);
      world.addBody(groundBody);

      // --- 修改：軌跡與粒子系統 (Trail System & White BG Removal) ---
      
      const textureLoader = new THREE.TextureLoader();
      const trailTextures = {
        leaf: textureLoader.load('leaf.png'),
        water: textureLoader.load('water.png'),
        fire: textureLoader.load('fire.png')
      };

      let particles = [];
      
      // 自定義 Shader：自動去除白色背景 (Chroma Key)
      function createChromaKeyMaterial(texture) {
        return new THREE.ShaderMaterial({
          uniforms: {
            pointTexture: { value: texture },
            opacity: { value: 1.0 }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform sampler2D pointTexture;
            uniform float opacity;
            varying vec2 vUv;
            void main() {
              vec4 color = texture2D(pointTexture, vUv);
              // 計算像素亮度
              float brightness = (color.r + color.g + color.b) / 3.0;
              // 如果接近純白 (亮度 > 0.85)，則視為透明
              if (brightness > 0.85) discard;
              gl_FragColor = vec4(color.rgb, color.a * opacity);
            }
          `,
          transparent: true,
          depthWrite: false,
          side: THREE.DoubleSide
        });
      }

      const trailMaterials = {
        leaf: createChromaKeyMaterial(trailTextures.leaf),
        water: createChromaKeyMaterial(trailTextures.water),
        fire: createChromaKeyMaterial(trailTextures.fire)
      };

      function spawnParticle(pos, type) {
        if (!trailMaterials[type]) return;

        const geometry = new THREE.PlaneGeometry(12, 12); // 稍微放大粒子
        const material = trailMaterials[type].clone();
        const mesh = new THREE.Mesh(geometry, material);

        // 位置隨機擾動
        mesh.position.copy(pos);
        mesh.position.x += (Math.random() - 0.5) * 5;
        mesh.position.z += (Math.random() - 0.5) * 5;
        mesh.position.y += (Math.random() - 0.5) * 5;
        mesh.lookAt(camera.position);

        scene.add(mesh);

        particles.push({
          mesh: mesh,
          life: 1.0,
          decay: 0.04 // 消失速度
        });
      }

      function updateTrails() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= p.decay;
          
          p.mesh.material.uniforms.opacity.value = p.life;
          p.mesh.position.y += 0.3; // 向上飄動
          
          const scale = 1 + (1 - p.life) * 0.5;
          p.mesh.scale.set(scale, scale, scale);
          p.mesh.lookAt(camera.position);

          if (p.life <= 0) {
            scene.remove(p.mesh);
            p.mesh.geometry.dispose();
            particles.splice(i, 1);
          }
        }
      }

      function updateLineTrail(duck) {
        if (!duck.trailLine || !duck.mesh) return;
        
        duck.trailHistory.push(duck.mesh.position.clone());
        if (duck.trailHistory.length > 25) {
            duck.trailHistory.shift();
        }

        if (duck.trailHistory.length > 1) {
            duck.trailLine.geometry.setFromPoints(duck.trailHistory);
            duck.trailLine.visible = true;
        } else {
            duck.trailLine.visible = false;
        }
      }

      // --- Game Logic ---
      let loadedModels = [];
      let modelTypes = []; 
      let ducks = [];
      let gameOver = false;
      let isPaused = false;
      let score = 0;
      let level = 1;
      const failThreshold = -100;

      const spawnHeight = 350;
      const duckScaleTarget = 70;

      let currentDropX = 0;
      let isAiming = false;
      let startDragX = 0;
      let baseDropX = 0;
      const sensitivity = 0.4;
const bgm = new Audio('music/game_music.m4a');
      bgm.loop = true;
      bgm.volume = 0.5;
      bgm.play().catch(e => {
        document.addEventListener('click', () => { bgm.play().catch(console.error); }, { once: true });
        document.addEventListener('touchstart', () => { bgm.play().catch(console.error); }, { once: true });
      });

      const collisionSound = new Audio('music/duck.m4a');
      collisionSound.volume = 0.8;
      const playCollisionSound = () => {
        const sound = collisionSound.cloneNode();
        sound.volume = 0.6 + Math.random() * 0.4;
        sound.play().catch(() => { });
      };

      const lineGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 1000, 0),
        new THREE.Vector3(0, -1000, 0)
      ]);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      const guideLine = new THREE.Line(lineGeometry, lineMaterial);
      guideLine.visible = false;
      scene.add(guideLine);

      // --- Model Loading with Mapping ---
      const loader = new FBXLoader();
      
      // 定義模型路徑與特效類型的對應
      const modelConfig = [
        { path: 'Model/cute+chick+3d+model.fbx', type: 'fire' },   // 紅色 -> Fire
        { path: 'Model/yellow+chick+toy+3d+model.fbx', type: 'line' }, // 黃色 -> Line
        { path: 'Model/green+chick+3d+model.fbx', type: 'leaf' },  // 綠色 -> Leaf
        { path: 'Model/blue+ice+chick+3d+model.fbx', type: 'water' } // 藍色 -> Water
      ];

      let loadedCount = 0;
      modelConfig.forEach((config, index) => {
        loader.load(config.path, function (object) {
          console.log(`Model loaded: ${config.path}`);

          const box = new THREE.Box3().setFromObject(object);
          const size = box.getSize(new THREE.Vector3());
          const maxAxis = Math.max(size.x, size.y, size.z);
          const scale = duckScaleTarget / maxAxis;

          object.scale.setScalar(scale);
          const center = box.getCenter(new THREE.Vector3());
          object.position.x -= center.x * scale;
          object.position.z -= center.z * scale;
          object.position.y -= center.y * scale;
          object.position.y -= (size.y * scale) / 2;

          object.traverse(function (child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              
              // --- 修改：增加自發光，避免角色太暗 ---
              if (child.material) {
                child.material.emissive = new THREE.Color(0x666666); 
                child.material.emissiveIntensity = 0.4;
                child.material.needsUpdate = true;
              }
            }
          });

          loadedModels[index] = object;
          modelTypes[index] = config.type;
          
          loadedCount++;
          if (loadedCount === modelConfig.length) {
            console.log("All models loaded!");
          }

        }, undefined, function (error) {
          console.error(`Error loading ${config.path}:`, error);
        });
      });

      function spawnDuck() {
        if (loadedCount < modelConfig.length || gameOver) return;

        const shape = new CANNON.Box(new CANNON.Vec3(25, 30, 25));
        const body = new CANNON.Body({
          mass: 1,
          material: defaultMaterial,
          shape: shape,
          linearDamping: 0.31,
          angularDamping: 0.5
        });

        const zoomFactor = Math.floor(score / 4);
        const currentSpawnHeight = spawnHeight + (zoomFactor * 250);

        body.position.set(currentDropX, currentSpawnHeight, 0);
        const baseRotation = -Math.PI / 2;
        const randomY = baseRotation + (Math.random() - 0.5) * 0.2;
        const randomTilt = (Math.random() - 0.5) * 0.2;
        body.quaternion.setFromEuler(randomTilt, randomY, randomTilt);

        let lastCollisionTime = 0;
        body.addEventListener('collide', (e) => {
          if (e.body === groundBody) return;
          const now = Date.now();
          if (now - lastCollisionTime > 200) {
            playCollisionSound();
            lastCollisionTime = now;
          }
        });

        world.addBody(body);

        const randIndex = Math.floor(Math.random() * loadedModels.length);
        const randomModel = loadedModels[randIndex];
        const effectType = modelTypes[randIndex];

        const mesh = randomModel.clone();
        scene.add(mesh);

        const duckObj = { mesh, body, type: effectType };

        // Setup for line trail
        if (effectType === 'line') {
             duckObj.trailHistory = [];
             // 建立一條白色的線
             const trailGeo = new THREE.BufferGeometry();
             const trailMat = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
             const trailLine = new THREE.Line(trailGeo, trailMat);
             scene.add(trailLine);
             duckObj.trailLine = trailLine;
        }

        ducks.push(duckObj);

        score++;
        level = Math.floor(score / 4) + 1;

        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        if (scoreDisplay) scoreDisplay.textContent = score;
        if (levelDisplay) levelDisplay.textContent = level < 10 ? '0' + level : level;

        targetCameraPos.z = initialCameraPos.z + (zoomFactor * 300);
        targetCameraPos.y = initialCameraPos.y + (zoomFactor * 250);
      }

      function startAim(event) {
        if (gameOver || isPaused) return;
        event.preventDefault();
        isAiming = true;
        guideLine.visible = true;
        if (event.touches) {
          startDragX = event.touches[0].clientX;
        } else {
          startDragX = event.clientX;
        }
        baseDropX = currentDropX;
      }

      function moveAim(event) {
        if (!isAiming || gameOver || isPaused) return;
        let clientX;
        if (event.touches) {
          clientX = event.touches[0].clientX;
        } else {
          clientX = event.clientX;
        }
        const deltaX = clientX - startDragX;
        let newX = baseDropX + (deltaX * sensitivity);
        newX = Math.max(-45, Math.min(45, newX));
        currentDropX = newX;
        guideLine.position.x = currentDropX;
      }

      function endAim(event) {
        if (!isAiming) return;
        isAiming = false;
        guideLine.visible = false;
        spawnDuck();
      }

      const dropBtn = document.getElementById('btn-drop');
      if (dropBtn) {
        dropBtn.addEventListener('touchstart', startAim, { passive: false });
        window.addEventListener('touchmove', moveAim, { passive: false });
        window.addEventListener('touchend', endAim);
        dropBtn.addEventListener('mousedown', startAim);
        window.addEventListener('mousemove', moveAim);
        window.addEventListener('mouseup', endAim);
      }

      const pauseBtn = document.getElementById('btn-pause');
      const pauseOverlay = document.getElementById('pause-overlay');
      const resumeBtn = document.getElementById('btn-resume');
      if (pauseBtn && pauseOverlay) {
        pauseBtn.addEventListener('click', () => {
          isPaused = true;
          pauseOverlay.classList.remove('hidden');
        });
      }
      if (resumeBtn && pauseOverlay) {
        resumeBtn.addEventListener('click', () => {
          isPaused = false;
          pauseOverlay.classList.add('hidden');
        });
      }

      const resetBtn = document.getElementById('btn-reset');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          window.location.href = 'game_countdown_screen.html';
        });
      }

      const screenshotBtn = document.getElementById('btn-screenshot');
      if (screenshotBtn) {
        screenshotBtn.addEventListener('click', () => {
          renderer.render(scene, camera);
          const dataURL = renderer.domElement.toDataURL('image/png');
          const link = document.createElement('a');
          link.download = `duck-stack-score-${score}.png`;
          link.href = dataURL;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      }

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const timeStep = 1 / 60;
      let frameCount = 0;

      function animate() {
        if (gameOver) return;
        requestAnimationFrame(animate);

        camera.position.lerp(targetCameraPos, 0.05);

        if (!isPaused) {
            world.step(timeStep);
            
            updateTrails(); // 更新所有粒子效果

            ducks.forEach(duck => {
              duck.mesh.position.copy(duck.body.position);
              duck.mesh.quaternion.copy(duck.body.quaternion);
              
              // 檢查移動速度
              const vel = duck.body.velocity;
              const speed = Math.sqrt(vel.x*vel.x + vel.y*vel.y + vel.z*vel.z);

              // 速度夠快才產生軌跡
              if (speed > 5) {
                if (duck.type === 'line') {
                    updateLineTrail(duck);
                } else if (frameCount % 4 === 0) { // 每4幀產生一個粒子
                    spawnParticle(duck.mesh.position.clone(), duck.type);
                }
              }

              if (duck.body.position.y < failThreshold) {
                console.log("Game Over!");
                gameOver = true;
                window.location.href = 'game_over_results.html?score=' + score;
              }
            });
            frameCount++;
        }

        renderer.render(scene, camera);
      }
      animate();
    }
  </script>
</head>
<body
  class="bg-background-light dark:bg-background-dark font-display h-screen w-screen overflow-hidden flex flex-col relative select-none">
  <div class="absolute inset-0 z-0">
    <div id="canvas-container"></div>
    <!-- AR Background -->
    <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
      <div class="relative w-64 h-96 flex flex-col items-center justify-center">
      </div>
    </div>
  </div>
  <div id="ui-overlay"
    class="absolute inset-0 z-10 flex flex-col justify-between h-full p-6 safe-area-inset pointers-events-none">
    <div class="flex justify-between items-start pointer-events-auto">
      <div
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-2xl p-3 flex flex-col items-center shadow-soft min-w-[80px]">
        <span class="text-xs text-gray-500 dark:text-gray-300 font-bold tracking-wider uppercase">Level</span>
        <span id="level-display" class="text-3xl font-black text-primary drop-shadow-sm">01</span>
      </div>
      <div
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-full px-6 py-2 shadow-soft mt-2">
        <span class="text-xl font-bold text-gray-800 dark:text-white">
          <span id="score-display">0</span> <span
            class="text-sm font-normal text-gray-500 dark:text-gray-300 ml-1">層</span>
        </span>
      </div>
      <button id="btn-pause"
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-2xl p-3 shadow-soft hover:bg-white/80 transition-colors group z-20">
        <span
          class="material-icons-round text-gray-700 dark:text-white text-3xl group-hover:text-primary transition-colors">pause</span>
      </button>
    </div>

    <!-- Pause Overlay -->
    <div id="pause-overlay"
      class="absolute inset-0 z-50 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center animate-fade-in pointer-events-auto">
      <div
        class="bg-surface-light dark:bg-surface-dark p-8 rounded-[2rem] shadow-2xl flex flex-col items-center space-y-6 border border-white/20 scale-100 hover:scale-105 transition-transform duration-300">
        <h2 class="text-4xl font-black text-gray-800 dark:text-white tracking-wide drop-shadow-md">暫停中</h2>
        <button id="btn-resume"
          class="group bg-primary hover:bg-yellow-400 text-white font-bold py-4 px-10 rounded-xl shadow-lg transition-all active:scale-95 text-xl flex items-center gap-2">
          <span class="material-icons-round text-2xl group-hover:animate-pulse">play_arrow</span>
          繼續遊戲
        </button>
      </div>
    </div>

    <div class="flex-grow"></div>
    <div class="flex flex-col items-center space-y-6 pb-24 pointer-events-auto">
      <div class="bg-black/60 backdrop-blur-md px-6 py-3 rounded-full animate-bounce shadow-lg border border-white/10">
        <p class="text-white text-base font-bold tracking-wide flex items-center gap-2">
          <span class="material-icons-round text-primary text-xl">view_in_ar</span>
          長按按鈕瞄準，<br>左右滑動，放開掉落
        </p>
      </div>
      <div class="w-full flex justify-between items-end px-4">
        <button id="btn-reset"
          class="bg-white dark:bg-gray-800 rounded-full p-4 shadow-lg active:scale-95 transition-transform border border-gray-100 dark:border-gray-700">
          <span class="material-icons-round text-gray-400 dark:text-gray-500 text-2xl">refresh</span>
        </button>
        <div class="relative group cursor-pointer active:scale-95 transition-transform">
          <div
            class="absolute -inset-1 bg-primary rounded-full blur opacity-40 group-hover:opacity-75 transition duration-200">
          </div>
          <button id="btn-drop"
            class="relative w-20 h-20 bg-gradient-to-br from-primary to-yellow-500 rounded-full shadow-xl flex items-center justify-center border-4 border-white dark:border-gray-800">
            <span class="material-icons-round text-white text-4xl font-bold">arrow_downward</span>
          </button>
        </div>
        <button id="btn-screenshot"
          class="bg-white dark:bg-gray-800 rounded-full p-4 shadow-lg active:scale-95 transition-transform border border-gray-100 dark:border-gray-700">
          <span class="material-icons-round text-gray-800 dark:text-white text-2xl">photo_camera</span>
        </button>
      </div>
    </div>
  </div>
  <img alt="feather pattern"
    class="absolute top-1/4 left-4 w-6 h-6 opacity-40 rotate-45 text-white filter invert pointer-events-none animate-pulse"
    src="https://lh3.googleusercontent.com/aida-public/AB6AXuDGLRZtLB_5DB3SANHBqWlqgBJMgURpW1JDFMqaft9fwpGfGS8FwXQW_kEvzUUGGiEiIMNRXYmck-pmUOdwduitMy85EXnXFRu-9ioryWROk3kNV-WDCWlHhbwTGVDIo4dviy5t2Whk42cbNelX4YFhSpxVTEHv6OpjmXF1pi19gn-W97Q848bLbIEpM5YEall1pCmpl-qeejY0148au15b-J9Ndll2Rsx1Fyfd68BMWs0mChYgswGaAk88yR5tgNGCWImuri4a" />
  <img alt="feather pattern"
    class="absolute bottom-1/3 right-8 w-4 h-4 opacity-30 -rotate-12 text-white filter invert pointer-events-none"
    src="https://lh3.googleusercontent.com/aida-public/AB6AXuABrUG7lA65wpBzRZ0EUagOhzIPk0QjPV4Vd9B4IrVRWbUxzoj2U_5alYPhc77ejb2Kp7hz-MPJpuK9H28bHe-kHoYeZNkmVY7qsCgnpmdsJT5UrwBJ6YvurZg85Q--kwS2X-Cz8FHGT5_wBdBH0D8rSpISJ6JcUVRT-c2PRS74QIOO8YJn0_t0y85d47ezC9TqbPuB0KDNTqBdccuiYrln1zllrWnN-YD9D76zYhYn0tT_dN6eKR90qNjHE1_VyriAl61UxdcS" />
</body>

</html>
