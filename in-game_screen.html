<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>In-Game Screen</title>
  <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&amp;display=swap"
    rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
  <script>
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            primary: "#FFCC00", // Extracted yellow from the duck/ui
            secondary: "#FF9900", // Orange accent
            "background-light": "#FFFBEB", // Very light yellow/warm white
            "background-dark": "#1F1F1F", // Dark grey for dark mode
            "surface-light": "rgba(255, 255, 255, 0.6)",
            "surface-dark": "rgba(0, 0, 0, 0.4)",
          },
          fontFamily: {
            display: ["'Noto Sans TC'", "sans-serif"],
          },
          borderRadius: {
            DEFAULT: "1rem",
            'xl': "1.5rem",
            '2xl': "2rem",
          },
          boxShadow: {
            'soft': '0 4px 20px -2px rgba(0, 0, 0, 0.1)',
            'glow': '0 0 15px rgba(255, 204, 0, 0.5)',
          }
        },
      },
    };
  </script>
  <style>
    @keyframes float {
      0% {
        transform: translateY(0px);
      }

      50% {
        transform: translateY(-10px);
      }

      100% {
        transform: translateY(0px);
      }
    }

    .ar-duck {
      animation: float 3s ease-in-out infinite;
    }

    body::-webkit-scrollbar {
      display: none;
    }

    .scan-line {
      width: 100%;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      animation: scan 3s linear infinite;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
    }

    @keyframes scan {
      0% {
        transform: translateY(-200px);
        opacity: 0;
      }

      10% {
        opacity: 1;
      }

      90% {
        opacity: 1;
      }

      100% {
        transform: translateY(200px);
        opacity: 0;
      }
    }
  </style>
  <style>
    body {
      min-height: 100dvh;
      height: 100dvh;
    }

    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      /* Above background gradient, below UI */
      pointer-events: none;
      /* Let clicks pass through if needed, or set to auto if interactive */
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "cannon-es": "https://esm.sh/cannon-es@0.20.0"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import * as CANNON from 'cannon-es';

    document.addEventListener('DOMContentLoaded', () => {
      initGame();
    });

    function initGame() {
      const container = document.getElementById('canvas-container');
      if (!container) return;

      // --- Three.js Setup ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      const initialCameraPos = new THREE.Vector3(0, 100, 400);
      const targetCameraPos = initialCameraPos.clone();
      camera.position.copy(initialCameraPos);
      camera.lookAt(0, 30, 0);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
      hemiLight.position.set(0, 1000, 0); // Moved up to 1000
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
      dirLight.position.set(100, 1000, 100); // Moved up to 1000 and angled
      dirLight.castShadow = true;
      scene.add(dirLight);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // --- Cannon.js Physics Setup ---
      const world = new CANNON.World({
        gravity: new CANNON.Vec3(0, -9.82 * 20, 0), // Scaled gravity
      });

      // Materials
      const defaultMaterial = new CANNON.Material('default');
      const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
        friction: 1000.0,    // EXTREEEME friction
        restitution: 0.0,   // No bounce
        contactEquationStiffness: 1e8, // Stiff contacts
        contactEquationRelaxation: 3,
      });
      world.addContactMaterial(defaultContactMaterial);

      // Ground Body (Finite Platform)
      // 100x100 size (halfExtent = 50, 1, 50)
      const groundShape = new CANNON.Box(new CANNON.Vec3(50, 5, 50));
      const groundBody = new CANNON.Body({
        type: CANNON.Body.STATIC,
        shape: groundShape,
        material: defaultMaterial
      });
      // Position at Y = -30, but box origin is center, so top face is at -30 + 5 = -25?
      // Let's position center at -35 so top face is around -30.
      groundBody.position.set(0, -35, 0);
      world.addBody(groundBody);

      // --- Game Logic ---
      let loadedModels = [];
      let ducks = [];
      let gameOver = false;
      let isPaused = false;
      let score = 0;
      let level = 1;
      const failThreshold = -100; // Y position to trigger game over

      const spawnHeight = 350;
      const duckRadius = 25;
      const duckScaleTarget = 70;

      // Load Models
      const loader = new FBXLoader();
      const modelPaths = [
        'Model/cute+chick+3d+model.fbx',
        'Model/yellow+chick+toy+3d+model.fbx',
        'Model/green+chick+3d+model.fbx',
        'Model/blue+ice+chick+3d+model.fbx'
      ];

      let loadedCount = 0;
      modelPaths.forEach(path => {
        loader.load(path, function (object) {
          console.log(`Model loaded: ${path}`);

          const box = new THREE.Box3().setFromObject(object);
          const size = box.getSize(new THREE.Vector3());
          const maxAxis = Math.max(size.x, size.y, size.z);
          const scale = duckScaleTarget / maxAxis;

          object.scale.setScalar(scale);

          // Center visual pivot
          const center = box.getCenter(new THREE.Vector3());
          object.position.x -= center.x * scale;
          object.position.z -= center.z * scale;
          object.position.y -= center.y * scale;
          object.position.y -= (size.y * scale) / 2;

          // Manual Material Assignment for missing textures
          let color = 0xffcc00; // Default Yellow
          if (path.includes('green')) color = 0x4caf50;
          if (path.includes('blue')) color = 0x2196f3;
          if (path.includes('cute')) color = 0xffea00; // Bright Yellow for "cute"

          // Emergency Fix: Use MeshBasicMaterial (Unlit)
          // This ignores lighting completely. If this is black, the geometry is broken.
          const material = new THREE.MeshBasicMaterial({
            color: color
          });

          object.traverse(function (child) {
            if (child.isMesh) {
              // Forcefully replace material
              child.material = material;

              // Ensure shadows and other properties
              child.castShadow = true;
              child.receiveShadow = true;

              // Debugging
              console.log(`Applied color ${color.toString(16)} to mesh: ${child.name}`);
            }
          });

          loadedModels.push(object);
          loadedCount++;

          if (loadedCount === modelPaths.length) {
            console.log("All models loaded!");
          }

        }, undefined, function (error) {
          console.error(`An error happened loading ${path}:`, error);
        });
      });

      function spawnDuck() {
        if (loadedModels.length === 0 || gameOver) return;

        // Physics Body
        // Box shape for "Tower Stacking"
        // HalfExtents: 25(x), 30(y), 25(z) -> Full Size: 50, 60, 50
        const shape = new CANNON.Box(new CANNON.Vec3(25, 30, 25));
        const body = new CANNON.Body({
          mass: 1,
          material: defaultMaterial,
          shape: shape,
          linearDamping: 0.31,
          angularDamping: 0.5
        });

        // Limit random range to fit on finite platform (50x50 half extents -> 100x100)
        // Spawn range ~40 to spawn somewhat centrally but with random deviations
        const range = 20;

        // Dynamic Spawn Height: Increase as tower grows to prevent clipping
        // Tower grows ~60 units per duck. 
        // We increase spawn height by 250 every 4 ducks (zoomFactor) to stay ahead.
        const zoomFactor = Math.floor(score / 4);
        const currentSpawnHeight = spawnHeight + (zoomFactor * 250);

        body.position.set(
          (Math.random() - 0.5) * range,
          currentSpawnHeight,
          (Math.random() - 0.5) * range
        );
        // Face Camera: Adjusted to -90 degrees (-Math.PI / 2) to fix "sideways" issue
        // The models likely have a native rotation of 90 degrees relative to their local forward.
        // User requested "Another 90" from Side(0) -> Front(-90).
        const baseRotation = -Math.PI / 2;
        const randomY = baseRotation + (Math.random() - 0.5) * 0.2;
        const randomTilt = (Math.random() - 0.5) * 0.2;
        body.quaternion.setFromEuler(randomTilt, randomY, randomTilt);

        world.addBody(body);

        // Visual Mesh - Random Selection
        const randomModel = loadedModels[Math.floor(Math.random() * loadedModels.length)];
        const mesh = randomModel.clone();
        scene.add(mesh);
        ducks.push({ mesh, body });

        // Update Score & Level
        score++;
        level = Math.floor(score / 4) + 1;

        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');

        if (scoreDisplay) scoreDisplay.textContent = score;
        if (levelDisplay) levelDisplay.textContent = level < 10 ? '0' + level : level;

        // Update Camera Target - Move Up and Back every 4 layers
        // Aggressive movement per user request "Not big enough"
        targetCameraPos.z = initialCameraPos.z + (zoomFactor * 300);
        targetCameraPos.y = initialCameraPos.y + (zoomFactor * 250);
      }

      const dropBtn = document.getElementById('btn-drop');
      if (dropBtn) {
        dropBtn.addEventListener('click', spawnDuck);
      }

      // --- UI Interactions ---

      // Pause Button
      const pauseBtn = document.getElementById('btn-pause');
      const pauseOverlay = document.getElementById('pause-overlay');
      const resumeBtn = document.getElementById('btn-resume');

      if (pauseBtn && pauseOverlay) {
        pauseBtn.addEventListener('click', () => {
          isPaused = true;
          pauseOverlay.classList.remove('hidden');
        });
      }

      if (resumeBtn && pauseOverlay) {
        resumeBtn.addEventListener('click', () => {
          isPaused = false;
          pauseOverlay.classList.add('hidden');
        });
      }

      // Reset Button
      const resetBtn = document.getElementById('btn-reset');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          window.location.href = 'game_countdown_screen.html';
        });
      }

      // Screenshot Button
      const screenshotBtn = document.getElementById('btn-screenshot');
      if (screenshotBtn) {
        screenshotBtn.addEventListener('click', () => {
          // Render frame immediately to ensure fresh buffer (just in case)
          renderer.render(scene, camera);

          const dataURL = renderer.domElement.toDataURL('image/png');
          const link = document.createElement('a');
          link.download = `duck-stack-score-${score}.png`;
          link.href = dataURL;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      }

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const timeStep = 1 / 60;
      function animate() {
        if (gameOver) return; // Stop loop on game over? Or just physics?

        requestAnimationFrame(animate);

        // Smooth Camera Zoom
        camera.position.lerp(targetCameraPos, 0.05);

        world.step(timeStep);

        ducks.forEach(duck => {
          duck.mesh.position.copy(duck.body.position);
          duck.mesh.quaternion.copy(duck.body.quaternion);

          // Game Over Check
          if (duck.body.position.y < failThreshold) {
            console.log("Game Over!");
            gameOver = true;
            window.location.href = 'game_over_results.html?score=' + score;
          }
        });

        renderer.render(scene, camera);
      }
      animate();
    }
  </script>
</head>

<body
  class="bg-background-light dark:bg-background-dark font-display h-screen w-screen overflow-hidden flex flex-col relative select-none">
  <div class="absolute inset-0 z-0">
    <div id="canvas-container"></div>
    <div
      class="w-full h-full bg-gradient-to-b from-gray-200 to-gray-300 dark:from-gray-800 dark:to-gray-900 object-cover opacity-80">
    </div>
    <div
      class="absolute bottom-0 w-full h-1/4 bg-gradient-to-t from-stone-300/50 to-transparent dark:from-stone-800/50">
    </div>
    <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
      <div class="relative w-64 h-96 flex flex-col items-center justify-center">
        <div
          class="relative w-48 h-48 border-2 border-white/30 border-dashed rounded-xl flex items-center justify-center animate-pulse">
          <div class="scan-line absolute top-1/2 w-full"></div>
          <div class="absolute inset-0 flex items-center justify-center">
            <span class="material-icons-round text-white/50 text-6xl">add</span>
          </div>
          <div class="absolute top-0 left-0 w-4 h-4 border-t-4 border-l-4 border-white/60 rounded-tl-lg -mt-1 -ml-1">
          </div>
          <div class="absolute top-0 right-0 w-4 h-4 border-t-4 border-r-4 border-white/60 rounded-tr-lg -mt-1 -mr-1">
          </div>
          <div class="absolute bottom-0 left-0 w-4 h-4 border-b-4 border-l-4 border-white/60 rounded-bl-lg -mb-1 -ml-1">
          </div>
          <div
            class="absolute bottom-0 right-0 w-4 h-4 border-b-4 border-r-4 border-white/60 rounded-br-lg -mb-1 -mr-1">
          </div>
        </div>
        <div class="absolute bottom-20 opacity-30">
          <div class="w-32 h-8 border-2 border-dashed border-white rounded-full"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="relative z-10 flex flex-col justify-between h-full p-6 safe-area-inset">
    <div class="flex justify-between items-start">
      <div
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-2xl p-3 flex flex-col items-center shadow-soft min-w-[80px]">
        <span class="text-xs text-gray-500 dark:text-gray-300 font-bold tracking-wider uppercase">Level</span>
        <span id="level-display" class="text-3xl font-black text-primary drop-shadow-sm">01</span>
      </div>
      <div
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-full px-6 py-2 shadow-soft mt-2">
        <span class="text-xl font-bold text-gray-800 dark:text-white">
          <span id="score-display">0</span> <span
            class="text-sm font-normal text-gray-500 dark:text-gray-300 ml-1">層</span>
        </span>
      </div>
      <button id="btn-pause"
        class="bg-surface-light dark:bg-surface-dark backdrop-blur-md border border-white/20 rounded-2xl p-3 shadow-soft hover:bg-white/80 transition-colors group z-20">
        <span
          class="material-icons-round text-gray-700 dark:text-white text-3xl group-hover:text-primary transition-colors">pause</span>
      </button>
    </div>

    <!-- Pause Overlay -->
    <div id="pause-overlay"
      class="absolute inset-0 z-50 bg-black/60 backdrop-blur-sm hidden flex items-center justify-center animate-fade-in">
      <div
        class="bg-surface-light dark:bg-surface-dark p-8 rounded-[2rem] shadow-2xl flex flex-col items-center space-y-6 border border-white/20 scale-100 hover:scale-105 transition-transform duration-300">
        <h2 class="text-4xl font-black text-gray-800 dark:text-white tracking-wide drop-shadow-md">暫停中</h2>
        <button id="btn-resume"
          class="group bg-primary hover:bg-yellow-400 text-white font-bold py-4 px-10 rounded-xl shadow-lg transition-all active:scale-95 text-xl flex items-center gap-2">
          <span class="material-icons-round text-2xl group-hover:animate-pulse">play_arrow</span>
          繼續遊戲
        </button>
      </div>
    </div>

    <div class="flex-grow"></div>
    <div class="flex flex-col items-center space-y-6 pb-8">
      <div class="bg-black/60 backdrop-blur-md px-6 py-3 rounded-full animate-bounce shadow-lg border border-white/10">
        <p class="text-white text-base font-bold tracking-wide flex items-center gap-2">
          <span class="material-icons-round text-primary text-xl">touch_app</span>
          點擊螢幕放置鴨子
        </p>
      </div>
      <div class="w-full flex justify-between items-end px-4">
        <button id="btn-reset"
          class="bg-white dark:bg-gray-800 rounded-full p-4 shadow-lg active:scale-95 transition-transform border border-gray-100 dark:border-gray-700">
          <span class="material-icons-round text-gray-400 dark:text-gray-500 text-2xl">refresh</span>
        </button>
        <div class="relative group cursor-pointer active:scale-95 transition-transform">
          <div
            class="absolute -inset-1 bg-primary rounded-full blur opacity-40 group-hover:opacity-75 transition duration-200">
          </div>
          <button id="btn-drop"
            class="relative w-20 h-20 bg-gradient-to-br from-primary to-yellow-500 rounded-full shadow-xl flex items-center justify-center border-4 border-white dark:border-gray-800">
            <span class="material-icons-round text-white text-4xl font-bold">arrow_downward</span>
          </button>
        </div>
        <button id="btn-screenshot"
          class="bg-white dark:bg-gray-800 rounded-full p-4 shadow-lg active:scale-95 transition-transform border border-gray-100 dark:border-gray-700">
          <span class="material-icons-round text-gray-800 dark:text-white text-2xl">photo_camera</span>
        </button>
      </div>
    </div>
  </div>
  <img alt="feather pattern"
    class="absolute top-1/4 left-4 w-6 h-6 opacity-40 rotate-45 text-white filter invert pointer-events-none animate-pulse"
    src="https://lh3.googleusercontent.com/aida-public/AB6AXuDGLRZtLB_5DB3SANHBqWlqgBJMgURpW1JDFMqaft9fwpGfGS8FwXQW_kEvzUUGGiEiIMNRXYmck-pmUOdwduitMy85EXnXFRu-9ioryWROk3kNV-WDCWlHhbwTGVDIo4dviy5t2Whk42cbNelX4YFhSpxVTEHv6OpjmXF1pi19gn-W97Q848bLbIEpM5YEall1pCmpl-qeejY0148au15b-J9Ndll2Rsx1Fyfd68BMWs0mChYgswGaAk88yR5tgNGCWImuri4a" />
  <img alt="feather pattern"
    class="absolute bottom-1/3 right-8 w-4 h-4 opacity-30 -rotate-12 text-white filter invert pointer-events-none"
    src="https://lh3.googleusercontent.com/aida-public/AB6AXuABrUG7lA65wpBzRZ0EUagOhzIPk0QjPV4Vd9B4IrVRWbUxzoj2U_5alYPhc77ejb2Kp7hz-MPJpuK9H28bHe-kHoYeZNkmVY7qsCgnpmdsJT5UrwBJ6YvurZg85Q--kwS2X-Cz8FHGT5_wBdBH0D8rSpISJ6JcUVRT-c2PRS74QIOO8YJn0_t0y85d47ezC9TqbPuB0KDNTqBdccuiYrln1zllrWnN-YD9D76zYhYn0tT_dN6eKR90qNjHE1_VyriAl61UxdcS" />
</body>

</html>
